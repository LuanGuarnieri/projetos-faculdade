/* Main.c file generated by New Project wizard
 *
 * Created:   sex ago 13 2021
 * Processor: 8086
 * Compiler:  Digital Mars C
 *
 * Before starting simulation set Internal Memory Size
 * in the 8086 model properties to 0x10000
 */

#define IO0 0000H
#define IO1 0200H
#define IO2 0400H
#define IO3 0600H
#define IO4 0800H
#define IO5 0A00H
#define IO6 0C00H
#define IO7 0E00H
#define IO8 1000H
#define IO9 1200H

 // 8251A USART 

#define ADR_USART_DATA   (IO9 + 00h)
//ONDE VOCE VAI MANDAR E RECEBER DADOS DO 8251

#define ADR_USART_CMD    (IO9 + 02h)
//É O LOCAL ONDE VOCE VAI ESCREVER PARA PROGRAMAR O 8251

#define ADR_USART_STAT   (IO9 + 02h)
//RETORNA O STATUS SE UM CARACTER FOI DIGITADO NO TERMINAL
//RETORNA O STATUS SE POSSO TRANSMITIR CARACTER PARA O TERMINAL

#define TAM 64
#define TAM_BYTE 3

unsigned char STRING[TAM + 1];

unsigned char STRING_NUMERO[TAM_BYTE + 1]; // 3 BYTES + 1

// Para rotina de RECEBE STRING
unsigned char QNT_LETRAS_DIGITADAS;

void RECEBE_CARACTER(void); 
void MANDA_CARACTER(void);
void MANDA_BYTE(void);

void RECEBE_STRING(void) {

	_asm
	{
		// TEM QUE SALVAR TODOS OS REGISTRADORES QUE FORAM ALTERADOS.
		pushf
		push ax 
		push si 

		//primeiro,zerar a quantidade de letras digitadas
		mov QNT_LETRAS_DIGITADAS, 0
		mov si, bx

		LEITURA_CARACTER :
			call RECEBE_CARACTER // AL TEM O CÓDIGO ASCII DA TECLA DIGITADA
			cmp al, 13 // verifica se o que tem dentro do AL é o enter (tem que cair fora da rotina)
			je TRATA_13_RECEBE_STRING // se for mesmo o enter, vai para este rótulo
			cmp al, 8 // verifica se o que tem dentro do AL é o backspace(cai para outra rotina)
			je TRATA_BS
			// antes de testar pra ver se é qualquer outro digito, tem que ver se ja chegou em 32 na STRING
			cmp QNT_LETRAS_DIGITADAS, TAM //compara se chegou em 32
			je TRATA_LIMITE // se chegou no 32 pula pra esse rótulo
			// se não é nenhum dos 3, pega akela tecla e joga na memória
			mov[bx], al // pega o que esta em AL e bota na posicao indicada por bx NA STRING. ou seja se bx esta em 0, vai escrever na primeira posicao da string (primeira letra da palvra)
			// em seguida, tem que fazer com que o bx mude para a proxima posicao (adicionar 1, pois é sequencial)
			inc bx //faz somar um direto ou poderia ser tbm add bx,1
			// se quisesse fazer uma senha, jogava asterisco no AL, ai simulava uma
			call MANDA_CARACTER // manda imprimir o que foi digitado
			inc QNT_LETRAS_DIGITADAS // adiciona 1 à quantidade de letras digitadas
			jmp LEITURA_CARACTER // FAZ A LEITURA DO PROX CARACTER (REPETE TUDO DNV) 

		TRATA_13_RECEBE_STRING :
			mov al, 0 // 0 =null
			mov[bx], al // mov para a posicao indicada pelo bx, o número 0 ( que é o NULL, fim de texto)
			jmp SAI_ROTINA_RECEBE_STRING


		TRATA_BS :

			cmp bx, si
			je LEITURA_CARACTER // se forem iguais, descarta a solicitacao de backspace. simplesmente tenta ler um novo caracter
			dec bx
			dec QNT_LETRAS_DIGITADAS
			mov al, 8 // 8 = backspace
			call MANDA_CARACTER // , manda imprimir no terminal
			jmp LEITURA_CARACTER


		TRATA_LIMITE :
			jmp LEITURA_CARACTER


		SAI_ROTINA_RECEBE_STRING :
	// restaurar e inverter a ordem do começo la em cima
			pop si
			pop ax
			popf

	}
}

// APOS A CHAMADA DESTE SUBPROGRAMA, AL  deve conter o byte digitado
void RECEBE_BYTE(void) {
	_asm
	{
		// TEM QUE SALVAR TODOS OS REGISTRADORES QUE FORAM ALTERADOS.
		pushf
		push cx
		push dx
		push si 

		mov QNT_LETRAS_DIGITADAS, 0
		mov si, bx // utiliza si como indicador de inicio 

		LEITURA_CARACTER_BYTE :

		    call RECEBE_CARACTER
			cmp al, 13
			je TRATA_13_RECEBE_STRING_BYTE
			cmp al, 8
			je TRATA_BS_BYTE

			cmp QNT_LETRAS_DIGITADAS, TAM_BYTE
			je TRATA_LIMITE_BYTE

			cmp al, '0'
			jl  LEITURA_CARACTER_BYTE 
			cmp al, '9'
			jg LEITURA_CARACTER_BYTE 
			
			cmp QNT_LETRAS_DIGITADAS, 0
			je SALVAR_PRIMEIRO_DIGITO
			
			cmp QNT_LETRAS_DIGITADAS, 1
			je SALVAR_SEGUNDO_DIGITO
			
			cmp QNT_LETRAS_DIGITADAS, 2
			je VERIFICAR_NUMERO_MAXIMO
			
			jmp ACEITAR_CARACTER

        TRATA_13_RECEBE_STRING_BYTE :
            mov al, 0
            mov[bx], al
            jmp SAI_ROTINA_RECEBE_STRING_BYTE

        TRATA_BS_BYTE :
            cmp bx, si
            je LEITURA_CARACTER_BYTE 
            dec bx
            dec QNT_LETRAS_DIGITADAS
            mov al, 8 
            call MANDA_CARACTER
            jmp LEITURA_CARACTER_BYTE


        TRATA_LIMITE_BYTE :
            jmp LEITURA_CARACTER_BYTE
        
        SALVAR_PRIMEIRO_DIGITO:
            mov ch, al
            jmp ACEITAR_CARACTER
        
        SALVAR_SEGUNDO_DIGITO:
            mov dh, al
            jmp ACEITAR_CARACTER
        
        VERIFICAR_NUMERO_MAXIMO:
            cmp ch, '1'
            je ACEITAR_CARACTER
            cmp ch, '2'
            jg TRATA_LIMITE_BYTE
            cmp dh, '5'
            jg TRATA_LIMITE_BYTE
            cmp al, '5'
            jg VERIFICAR_SEGUNDO_DIGITO
            jmp ACEITAR_CARACTER
        
        VERIFICAR_SEGUNDO_DIGITO:
            cmp dh, '4'
            jg TRATA_LIMITE_BYTE;
            jmp ACEITAR_CARACTER 
        
        ACEITAR_CARACTER:
            mov[bx], al
            inc bx
            call MANDA_CARACTER
            inc QNT_LETRAS_DIGITADAS
            jmp LEITURA_CARACTER_BYTE

        SAI_ROTINA_RECEBE_STRING_BYTE:

            cmp QNT_LETRAS_DIGITADAS, 3
            je SALVA_TRES_DIGITOS

            cmp QNT_LETRAS_DIGITADAS, 2
            je SALVA_DOIS_DIGITOS

            cmp QNT_LETRAS_DIGITADAS, 1
            je SALVA_UM_DIGITO

        
        SALVA_TRES_DIGITOS:
            lea bx, STRING_NUMERO 

            mov dh, [bx]   			 // move conteudo de bx para dh
            sub dh, 48     			 // subtrai 48 de dh para que se torne um byte (tabela ascii)
            inc bx          		 // incrementa bx para ler o próximo digito
            
            mov dl, [bx]     		
            sub dl, 48      
            inc bx
            
            mov ch, [bx]	
            sub ch, 48      

            // no fim, dh --> centena, dl --> dezena, ch --> unidade		
            // ((DL * 10) + CH) + (DH * 100)
            mov al, dl        
            mov cl, 10       
            mul cl           
            add al, ch	 
            
            mov dl, al 	 

            mov al, dh	 
            mov cl, 100	 
            mul cl		

            add al, dl       

            jmp REGISTRADORES_SAI_STRING

        SALVA_DOIS_DIGITOS:
            lea bx, STRING_NUMERO // bx precisa apontar para a string_numero
            mov dh, [bx]    	  // registrador filho do dx (dh) vai receber o conteudo de bx
            sub dh, 48            // subtrai 48 pra ver que número que é. 
            inc bx                // para ler o proximo caracter

            mov dl, [bx]          // pega o conteudo de bx  e joga em dl, outro filho de dx
            sub dl, 48            // subtrai 48 pra ver que número que é.
                                    
            mov al, dh            
            mov cl, 10            
            mul cl                // multiplica por al, esta implicito
                                    
            add al, dl
            
            jmp REGISTRADORES_SAI_STRING

        SALVA_UM_DIGITO:
            lea bx, STRING_NUMERO
            mov dh, [bx]
            sub dh, 48
            mov al, dh
            jmp REGISTRADORES_SAI_STRING
            // Manda bx apontar pra string_numero, salva em dh, subtrai 48, salva em al.

        REGISTRADORES_SAI_STRING:
            pop si
            pop dx
            pop cx
            popf
	}
}


void MANDA_BYTE(void) {

	_asm {
	     pushf
	     push ax 
	     push bx    
	     push dx

	     cmp QNT_LETRAS_DIGITADAS, 3
	     je MANDA_3_DIGITOS

	     cmp QNT_LETRAS_DIGITADAS, 2
	     je MANDA_2_DIGITOS

	     cmp QNT_LETRAS_DIGITADAS, 1
	     je MANDA_1_DIGITO

        MANDA_3_DIGITOS:

	       push ax		 // Para salvar o ax pq vai precisar depois
	       mov ah, 0     // Bota 0 em ah para garantir que não tenha outro número interferindo.
	       mov cl, 100   // Bota 100 em CL
	       div cl        // divide ax por cl
	       add al, 48
	       call MANDA_CARACTER
	       
	       sub al, 48       
	       mul cl  
	       mov dx,ax
	       pop ax        
	       sub ax, dx 
	       
	       mov ah, 0
	       mov cl, 10
	       div cl       // divide ax por cl
	       add al, 48 
	       call MANDA_CARACTER

	       add ah, 48
	       mov al, ah 
	       call MANDA_CARACTER 

	       jmp REGISTRADORES_MANDA_BYTE

        MANDA_2_DIGITOS:
	       mov ah,0 
	       mov cl, 10
	       div cl   
	       add al,48 
	       call MANDA_CARACTER 

	       mov al,ah
	       add al,48
	       call MANDA_CARACTER

	       jmp REGISTRADORES_MANDA_BYTE

        MANDA_1_DIGITO:
		mov ah,0
        	add al,48

		call MANDA_CARACTER
		
	REGISTRADORES_MANDA_BYTE:
	       pop dx
	       pop bx
	       pop ax
	       popf 
	}
}

void PULA_LINHA(void) {

	_asm {

		pushf
		push ax
		mov al, 13
		call MANDA_CARACTER
		mov al, 10
		call MANDA_CARACTER
		pop ax
		popf

	}
}

// tenha certeza que bx aponte para STRING
// antes de chamar essa manda_string tem que pedir pro BX apontar pra string que vc quer imprimir

   //vai imprimir o texto previamente digitado
void MANDA_STRING(void) {

	_asm {
		//preservar flag e ax
		pushf
		push ax
		PROCURA_NULL :
		// é indicavel jogar bx num registrador para garantir que esta comparando um valor de 8 bits e nao 16, pq se n da erro
		mov al, [bx]
		cmp al, 0 // COMPARA SE CONTEUDO APONTADO POR BX É NULL. ou seja, chegou no fim da STRING
		je SAI_MANDA_STRING // se sim, cai fora
		mov al, [bx] // prepara al com conteudo apontado por bx
		call MANDA_CARACTER
		add bx, 1
		jmp PROCURA_NULL



		SAI_MANDA_STRING:
			pop ax
			popf
	}
}

void INICIALIZA_8251(void)
{
	_asm {
		MOV AL, 0
		MOV DX, ADR_USART_CMD
		OUT DX, AL
		OUT DX, AL
		OUT DX, AL
		MOV AL, 40H
		OUT DX, AL
		MOV AL, 4DH
		OUT DX, AL
		MOV AL, 37H
		OUT DX, AL
	}
}

//NAO ESQUECA ANTES DE JOGAR O CODIGO ASCII EM AL
void MANDA_CARACTER(void)
{
	_asm
	{
		PUSHF
		PUSH DX
		PUSH AX; SALVA AL
		BUSY :
		MOV DX, ADR_USART_STAT
		IN  AL, DX
		TEST AL, 1
		JZ BUSY
		MOV DX, ADR_USART_DATA
		POP AX; RESTAURA AL
		OUT DX, AL
		POP DX
		POPF
	}
}

//AO EXECUTAR ESTA ROTINA, TEREMOS EM AL O CODIGO ASCII DO QUE FOI DIGITADO NO TERMINAL
void RECEBE_CARACTER(void)
{
	_asm {
		PUSHF
		PUSH DX
		AGUARDA_CARACTER :
		MOV DX, ADR_USART_STAT
		IN  AL, DX
		TEST AL, 2
		JZ AGUARDA_CARACTER
		MOV DX, ADR_USART_DATA
		IN  AL, DX
		SHR AL, 1
		NAO_RECEBIDO:
		POP DX
		POPF
	}
}

void Testa_74154(void)
{
	_asm
	{
		mov dx, IO0  //o endereco da controladora deve estar em dx (16 bits)
		out dx, al //dado a ser escrito na controladora deve estar em Al (8 bits)
		mov dx, IO1  //o endereco da controladora deve estar em dx (16 bits)
		out dx, al //dado a ser escrito na controladora deve estar em Al (8 bits)
		mov dx, IO2  //o endereco da controladora deve estar em dx (16 bits)
		out dx, al //dado a ser escrito na controladora deve estar em Al (8 bits)
		mov dx, IO3  //o endereco da controladora deve estar em dx (16 bits)
		out dx, al //dado a ser escrito na controladora deve estar em Al (8 bits)
		mov dx, IO4  //o endereco da controladora deve estar em dx (16 bits)
		out dx, al //dado a ser escrito na controladora deve estar em Al (8 bits)
		mov dx, IO5  //o endereco da controladora deve estar em dx (16 bits)
		out dx, al //dado a ser escrito na controladora deve estar em Al (8 bits)
	}
}

void Le_Escreve(void)
{
	_asm
	{
		mov dx, IO2; faz a leitura do teclado
		in  al, dx; al = xxxxxxxx
		mov dx, IO0
		out dx, al; manda dado lido para controladora IO0
		mov dx, IO1
		out dx, al; manda dado lido para controladora IO0
	}
}

void Pausa(void)
{
	//esta Rotina será transformada em Assembly e fará uso de registradores
	unsigned int Cont = 3000;
	while (Cont--)
	{
	}
}

//esta rotina espera que o reg AL
//tenha o valor binario!
void Conv_Bin_Dec(void)
{
	_asm
	{
		cmp al, 0
		je converte_0
		cmp al, 1
		je converte_1
		cmp al, 2
		je converte_2
		cmp al, 3
		je converte_3
		cmp al, 4
		je converte_4
		cmp al, 5
		je converte_5
		cmp al, 6
		je converte_6
		cmp al, 7
		je converte_7
		cmp al, 8
		je converte_8
		cmp al, 9
		je converte_9
		;   GFEDCBA
		mov al, 0b01111001; codigo de erro "E"
		jmp sai_converte_bin_dec

		converte_0 :
		;   GFEDCBA
			mov al, 0b00111111
			jmp sai_converte_bin_dec
			converte_1 :
		;   GFEDCBA
			mov al, 0b00000110
			jmp sai_converte_bin_dec
			converte_2 :
		;   GFEDCBA
			mov al, 0b01011011
			jmp sai_converte_bin_dec
			converte_3 :
		;   GFEDCBA
			mov al, 0b01001111
			jmp sai_converte_bin_dec
			converte_4 :
		;   GFEDCBA
			mov al, 0b01100110
			jmp sai_converte_bin_dec
			converte_5 :
		;   GFEDCBA
			mov al, 0b01101101
			jmp sai_converte_bin_dec
			converte_6 :
		;   GFEDCBA
			mov al, 0b01111101
			jmp sai_converte_bin_dec
			converte_7 :
		;   GFEDCBA
			mov al, 0b00000111
			jmp sai_converte_bin_dec
			converte_8 :
		;   GFEDCBA
			mov al, 0b01111111
			jmp sai_converte_bin_dec
			converte_9 :
		;   GFEDCBA
			mov al, 0b01100111
			jmp sai_converte_bin_dec

			sai_converte_bin_dec :
	}
}

void main(void)
{
	// Write your code here

	INICIALIZA_8251();
	while (1) {
		//_asm lea bx, STRING // bx está apontando para aquela string
		//_asm call RECEBE_STRING
		//_asm call PULA_LINHA
		//_asm lea bx, STRING // PRA TER CERTEZA QUE O BX ESTA APONTANDO PRA STRING ANTES DE MANDAR_STRING
		//_asm call MANDA_STRING
		//_asm call PULA_LINHA


		_asm lea bx, STRING_NUMERO
		_asm call RECEBE_BYTE
		_asm call PULA_LINHA
		_asm call MANDA_BYTE //imprime valor de al
		_asm call PULA_LINHA

	}
}